{"version":3,"file":"index.js","sources":["../src/parse.ts"],"sourcesContent":["/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n *\n * Based on code from the {@link https://github.com/EventSource/eventsource | EventSource module},\n * which is licensed under the MIT license. And copyrighted the EventSource GitHub organisation.\n */\nimport type {EventSourceParseCallback, EventSourceParser} from './types.js'\n\n/**\n * Creates a new EventSource parser.\n *\n * @param onParse - Callback to invoke when a new event is parsed, or a new reconnection interval\n *                  has been sent from the server\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(onParse: EventSourceParseCallback): EventSourceParser {\n  // Processing state\n  let isFirstChunk: boolean\n  let buffer: string\n  let startingPosition: number\n  let startingFieldLength: number\n\n  // Event state\n  let eventId: string | undefined\n  let eventName: string | undefined\n  let data: string\n\n  reset()\n  return {feed, reset}\n\n  function reset(): void {\n    isFirstChunk = true\n    buffer = ''\n    startingPosition = 0\n    startingFieldLength = -1\n\n    eventId = undefined\n    eventName = undefined\n    data = ''\n  }\n\n  function feed(chunk: string): void {\n    buffer = buffer ? buffer + chunk : chunk\n\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream.\n    // Note that we do not strip any non - UTF8 BOM, as eventsource streams are\n    // always decoded as UTF8 as per the specification.\n    if (isFirstChunk && hasBom(buffer)) {\n      buffer = buffer.slice(BOM.length)\n    }\n\n    isFirstChunk = false\n\n    // Set up chunk-specific processing state\n    const length = buffer.length\n    let position = 0\n    let discardTrailingNewline = false\n\n    // Read the current buffer byte by byte\n    while (position < length) {\n      // EventSource allows for carriage return + line feed, which means we\n      // need to ignore a linefeed character if the previous character was a\n      // carriage return\n      // @todo refactor to reduce nesting, consider checking previous byte?\n      // @todo but consider multiple chunks etc\n      if (discardTrailingNewline) {\n        if (buffer[position] === '\\n') {\n          ++position\n        }\n        discardTrailingNewline = false\n      }\n\n      let lineLength = -1\n      let fieldLength = startingFieldLength\n      let character: string\n\n      for (let index = startingPosition; lineLength < 0 && index < length; ++index) {\n        character = buffer[index]\n        if (character === ':' && fieldLength < 0) {\n          fieldLength = index - position\n        } else if (character === '\\r') {\n          discardTrailingNewline = true\n          lineLength = index - position\n        } else if (character === '\\n') {\n          lineLength = index - position\n        }\n      }\n\n      if (lineLength < 0) {\n        startingPosition = length - position\n        startingFieldLength = fieldLength\n        break\n      } else {\n        startingPosition = 0\n        startingFieldLength = -1\n      }\n\n      parseEventStreamLine(buffer, position, fieldLength, lineLength)\n\n      position += lineLength + 1\n    }\n\n    if (position === length) {\n      // If we consumed the entire buffer to read the event, reset the buffer\n      buffer = ''\n    } else if (position > 0) {\n      // If there are bytes left to process, set the buffer to the unprocessed\n      // portion of the buffer only\n      buffer = buffer.slice(position)\n    }\n  }\n\n  function parseEventStreamLine(\n    lineBuffer: string,\n    index: number,\n    fieldLength: number,\n    lineLength: number\n  ) {\n    if (lineLength === 0) {\n      // We reached the last line of this event\n      if (data.length > 0) {\n        onParse({\n          type: 'event',\n          id: eventId,\n          event: eventName || undefined,\n          data: data.slice(0, -1), // remove trailing newline\n        })\n\n        data = ''\n        eventId = undefined\n      }\n      eventName = undefined\n      return\n    }\n\n    const noValue = fieldLength < 0\n    const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength))\n    let step = 0\n\n    if (noValue) {\n      step = lineLength\n    } else if (lineBuffer[index + fieldLength + 1] === ' ') {\n      step = fieldLength + 2\n    } else {\n      step = fieldLength + 1\n    }\n\n    const position = index + step\n    const valueLength = lineLength - step\n    const value = lineBuffer.slice(position, position + valueLength).toString()\n\n    if (field === 'data') {\n      data += value ? `${value}\\n` : '\\n'\n    } else if (field === 'event') {\n      eventName = value\n    } else if (field === 'id' && !value.includes('\\u0000')) {\n      eventId = value\n    } else if (field === 'retry') {\n      const retry = parseInt(value, 10)\n      if (!Number.isNaN(retry)) {\n        onParse({type: 'reconnect-interval', value: retry})\n      }\n    }\n  }\n}\n\nconst BOM = [239, 187, 191]\n\nfunction hasBom(buffer: string) {\n  return BOM.every((charCode: number, index: number) => buffer.charCodeAt(index) === charCode)\n}\n"],"names":["createParser","onParse","isFirstChunk","buffer","startingPosition","startingFieldLength","eventId","eventName","data","reset","feed","chunk","hasBom","slice","BOM","length","position","discardTrailingNewline","lineLength","fieldLength","character","index","parseEventStreamLine","lineBuffer","type","id","event","noValue","field","step","valueLength","value","toString","includes","retry","parseInt","Number","isNaN","every","charCode","charCodeAt"],"mappings":"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"}